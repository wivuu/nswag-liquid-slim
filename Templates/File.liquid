/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v{{ ToolchainVersion }} (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

{{ ExtensionCodeImport -}}
{% if ImportRequiredTypes -%}
{%     if GenerateClientClasses -%}
{%         if Framework.IsAngular -%}

{%             if Framework.UseRxJs5 -%}
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
{%             else -%}
import { mergeMap as {{ Framework.RxJs.ObservableMergeMapMethod }}, catchError as {{ Framework.RxJs.ObservableCatchMethod }} } from 'rxjs/operators';
import { Observable, {% if UseTransformOptionsMethod %}from as {{ Framework.RxJs.ObservableFromMethod }}, {% endif %}throwError as {{ Framework.RxJs.ObservableThrowMethod }}, of as {{ Framework.RxJs.ObservableOfMethod }} } from 'rxjs';
{%             endif -%}
import { Injectable, Inject, Optional, {{ Framework.Angular.InjectionTokenType }} } from '@angular/core';
{%             if Framework.Angular.UseHttpClient -%}
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
{%             else -%}
import { Http, Headers, ResponseContentType, Response{% if UseTransformOptionsMethod %}, RequestOptionsArgs{% endif %} } from '@angular/http';
{%             endif -%}
{%         endif -%}
{%         if Framework.IsAurelia -%}

import { inject } from 'aurelia-framework';
import { HttpClient, RequestInit } from 'aurelia-fetch-client';
{%         endif -%}
{%         if Framework.IsAngularJS -%}

import * as ng from 'angular';
{%         endif -%}
{%         if Framework.IsAxios -%}

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
{%         endif -%}
{%         if Framework.IsKnockout -%}

import * as ko from 'knockout';
{%         endif -%}
{%         if Framework.IsJQuery -%}

import * as jQuery from 'jquery';
{%         endif -%}
{%     endif -%}
{%     if Framework.UseMomentJS -%}

import * as moment from 'moment';
{%         if RequiresMomentJSDuration -%}
import 'moment-duration-format';
{%         endif -%}
{%     endif -%}
{% endif -%}

{% if HasModuleName -%}
{% if ExportTypes %}export {% endif %}module {{ ModuleName }} {
{% endif -%}
{% if HasNamespace -%}
namespace {{ Namespace }} {
{% endif -%}
{% if GenerateClientClasses and Framework.IsAngular -%}
{% if ExportTypes %}export {% endif %}const {{ Framework.Angular.BaseUrlTokenName }} = new {{ Framework.Angular.InjectionTokenType }}{% if Framework.Angular.InjectionTokenType == "InjectionToken" %}<string>{% endif %}('{{ Framework.Angular.BaseUrlTokenName }}');

{% endif -%}
{{ ExtensionCodeTop }}

{{ Clients }}

{{ Types }}

{% if WrapResponses and GenerateResponseClasses -%}
{%     for responseClassName in ResponseClassNames -%}
{% if ExportTypes %}export {% endif %}class {{ responseClassName }}<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;
        
    constructor(status: number, headers: { [key: string]: any; }, result: TResult) 
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

{%     endfor -%}
{% endif -%}
{% if RequiresFileParameterInterface -%}
{% if ExportTypes %}export {% endif %}interface FileParameter {
    data: any;
    fileName: string;
}

{% endif -%}
{% if RequiresFileResponseInterface -%}
{% if ExportTypes %}export {% endif %}interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

{% endif -%}

{{ ExtensionCodeBottom }}
{% if HasNamespace -%}
}
{% endif -%}
{% if HasModuleName -%}
}
{% endif -%}

type HttpMethodsWithBody = "PUT" | "POST" | "PATCH";
type HttpMethods = "HEAD" | "GET" | "DELETE" | HttpMethodsWithBody;

{% if UseGetBaseUrlMethod -%}
let baseUrl = getBaseUrl("{{ BaseUrl }}");
{% else -%}
let baseUrl = "{{ BaseUrl }}";
{% endif -%}

export function setBaseUrl(url: string) {
    baseUrl = url;
}

const jsonRequestInfo : RequestInit = {
    headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
}

const defaultRequestInfo : RequestInit = {
    headers: {
        "Accept": "application/json"
    }
}

const pattern = /\/\{\w+\}/g;

/** Format params string, removing {template} values and any matches from the params object */
function formatParams<T extends { [key: string]: any }>(info: string, model: T) {
    const matches = info.match(pattern);

    if (matches)
        for (const m of matches) {
            const key   = m.slice(2, -1),
                  value = model[key] as any;
            
            if (value !== null && value !== undefined) {
                info = info.replace(m, "/" + encodeURIComponent("" + value));
                delete model[key];
            }
            else
                info = info.replace(m, "");
        }

    return info;
}

/** Format a querystring from an object */
function formatQueryString<T extends { [key: string]: any }>(model: T) {
    const keys = Object.keys(model);
    let qs     = "";

    for (let i = 0; i < keys.length; ++i) {
        const key   = keys[i], 
              value = model[key];
        
        qs += (i === 0 ? "?" : "&") +
              encodeURIComponent(key) + "=" + encodeURIComponent("" + value);
    }

    return qs;
}

/** Return FormData */
function getFormData<T extends { [key: string]: any }>(model?: T) {
    const data = new FormData();

    if (model !== undefined)
        for (const key of Object.keys(model)) {
            const value = model[key];

            if (value !== null && value !== undefined)
                data.append(key, value);
        }

    return data;
}

/** API Base function */
async function apiBase(method: HttpMethods, info: string, params?: object | null, body?: string | FormData) {
    info     = !!params ? formatParams(info, params) : info;
    const qs = !!params ? formatQueryString(params)  : "";

    const response = await fetch(
        baseUrl + info + qs,
        { 
            method, 
            ...body instanceof FormData ? defaultRequestInfo : jsonRequestInfo,
            body
        });

    return await response.json();
}