/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Log user into the system
     */
    login(model: LoginViewModel): Promise<UserProfileViewModel> {
        let url_ = this.baseUrl + "/api/User/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<UserProfileViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfileViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ValidationProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfileViewModel>(<any>null);
    }

    /**
     * Log user out
     */
    logout(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/User/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Request a password reset token sent via email
     */
    sendReset(model: ForgotPasswordViewModel): Promise<void> {
        let url_ = this.baseUrl + "/api/User/SendReset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendReset(_response);
        });
    }

    protected processSendReset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ValidationProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Reset account password given a valid reset code
     * @param code (optional) 
     */
    resetPassword(email: string | null, code: string | null | undefined, reset: PasswordResetViewModel): Promise<UserProfileViewModel> {
        let url_ = this.baseUrl + "/api/User/ResetPassword/{email}?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reset);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<UserProfileViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfileViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ValidationProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfileViewModel>(<any>null);
    }

    /**
     * Check if invitation valid/exists
     */
    viewInvite(code: string | null, email: string | null): Promise<ViewInviteViewModel> {
        let url_ = this.baseUrl + "/api/User/ViewInvite/{code}?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processViewInvite(_response);
        });
    }

    protected processViewInvite(response: Response): Promise<ViewInviteViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ViewInviteViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ViewInviteViewModel>(<any>null);
    }

    /**
     * Accept an invitation to create a user account
     * @param accountExists (optional) 
     * @param id (optional) 
     * @param image_Url (optional) 
     * @param image_ImageData (optional) 
     * @param aboutMe (optional) 
     * @param customQuote (optional) 
     */
    acceptInvite(code: string | null, password: string | null, confirmPassword: string | null, accountExists: boolean | undefined, id: string | undefined, email: string | null, firstName: string | null, lastName: string | null, title: string | null, phone: string | null, image_Url: string | null | undefined, image_ImageData: FileParameter | null | undefined, aboutMe: string | null | undefined, customQuote: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/AcceptInvite/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (password !== null && password !== undefined)
            content_.append("Password", password.toString());
        if (confirmPassword !== null && confirmPassword !== undefined)
            content_.append("ConfirmPassword", confirmPassword.toString());
        if (accountExists === null || accountExists === undefined)
            throw new Error("The parameter 'accountExists' cannot be null.");
        else
            content_.append("AccountExists", accountExists.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (firstName !== null && firstName !== undefined)
            content_.append("FirstName", firstName.toString());
        if (lastName !== null && lastName !== undefined)
            content_.append("LastName", lastName.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (phone !== null && phone !== undefined)
            content_.append("Phone", phone.toString());
        if (image_Url !== null && image_Url !== undefined)
            content_.append("Image.Url", image_Url.toString());
        if (image_ImageData !== null && image_ImageData !== undefined)
            content_.append("Image.ImageData", image_ImageData.data, image_ImageData.fileName ? image_ImageData.fileName : "Image.ImageData");
        if (aboutMe !== null && aboutMe !== undefined)
            content_.append("AboutMe", aboutMe.toString());
        if (customQuote !== null && customQuote !== undefined)
            content_.append("CustomQuote", customQuote.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptInvite(_response);
        });
    }

    protected processAcceptInvite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ValidationProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Retrieve user's profile information
     */
    getProfile(): Promise<UserProfileViewModel> {
        let url_ = this.baseUrl + "/api/User/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<UserProfileViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfileViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfileViewModel>(<any>null);
    }

    /**
     * Update user profile
     * @param id (optional) 
     * @param image_Url (optional) 
     * @param image_ImageData (optional) 
     * @param aboutMe (optional) 
     * @param customQuote (optional) 
     */
    putProfile(id: string | undefined, email: string | null, firstName: string | null, lastName: string | null, title: string | null, phone: string | null, image_Url: string | null | undefined, image_ImageData: FileParameter | null | undefined, aboutMe: string | null | undefined, customQuote: string | null | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/User/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (firstName !== null && firstName !== undefined)
            content_.append("FirstName", firstName.toString());
        if (lastName !== null && lastName !== undefined)
            content_.append("LastName", lastName.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (phone !== null && phone !== undefined)
            content_.append("Phone", phone.toString());
        if (image_Url !== null && image_Url !== undefined)
            content_.append("Image.Url", image_Url.toString());
        if (image_ImageData !== null && image_ImageData !== undefined)
            content_.append("Image.ImageData", image_ImageData.data, image_ImageData.fileName ? image_ImageData.fileName : "Image.ImageData");
        if (aboutMe !== null && aboutMe !== undefined)
            content_.append("AboutMe", aboutMe.toString());
        if (customQuote !== null && customQuote !== undefined)
            content_.append("CustomQuote", customQuote.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutProfile(_response);
        });
    }

    protected processPutProfile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Change user password
     */
    changePassword(input: PasswordChangeViewModel): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ValidationProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Ping to test if user still logged in
     */
    ping(): Promise<void> {
        let url_ = this.baseUrl + "/api/User/Ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Session has ended", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class LeadsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Retrieve leads by date; filtered, sorted, and paged
     * @param start (optional) 
     * @param end (optional) 
     * @param filter (optional) 
     * @param sortBy (optional) 
     * @param includeCount (optional) 
     * @param sortDirection (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    findLeads(start: Date | undefined, end: Date | undefined, filter: string | undefined, sortBy: string | null | undefined, includeCount: boolean | undefined, sortDirection: SortDirection | undefined, page: number | undefined, pageSize: number | undefined, partner: string): Promise<GridDataOfLeadViewModel> {
        let url_ = this.baseUrl + "/api/{partner}/Leads?";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (includeCount === null)
            throw new Error("The parameter 'includeCount' cannot be null.");
        else if (includeCount !== undefined)
            url_ += "IncludeCount=" + encodeURIComponent("" + includeCount) + "&"; 
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeads(_response);
        });
    }

    protected processFindLeads(response: Response): Promise<GridDataOfLeadViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GridDataOfLeadViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GridDataOfLeadViewModel>(<any>null);
    }

    /**
     * Retrieve leads by date with statistics; filtered, sorted, and paged
     * @param start (optional) 
     * @param end (optional) 
     * @param filter (optional) 
     * @param sortBy (optional) 
     * @param includeCount (optional) 
     * @param sortDirection (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    findLeadsWithStatistics(start: Date | undefined, end: Date | undefined, filter: string | undefined, sortBy: string | null | undefined, includeCount: boolean | undefined, sortDirection: SortDirection | undefined, page: number | undefined, pageSize: number | undefined, partner: string): Promise<GridDataOfLeadWithStatsViewModel> {
        let url_ = this.baseUrl + "/api/{partner}/Leads/WithStatistics?";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (includeCount === null)
            throw new Error("The parameter 'includeCount' cannot be null.");
        else if (includeCount !== undefined)
            url_ += "IncludeCount=" + encodeURIComponent("" + includeCount) + "&"; 
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadsWithStatistics(_response);
        });
    }

    protected processFindLeadsWithStatistics(response: Response): Promise<GridDataOfLeadWithStatsViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GridDataOfLeadWithStatsViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GridDataOfLeadWithStatsViewModel>(<any>null);
    }

    /**
     * Retrieve lead by id
     */
    getLead(id: string, partner: string): Promise<LeadDetailViewModel> {
        let url_ = this.baseUrl + "/api/{partner}/Leads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLead(_response);
        });
    }

    protected processGetLead(response: Response): Promise<LeadDetailViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadDetailViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadDetailViewModel>(<any>null);
    }
}

export class LookupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Retrieve all areas within input state
     * @param state (optional) 
     */
    geographyPickerAreas(state: string | null | undefined): Promise<GeographicAreaSelectionViewModel[]> {
        let url_ = this.baseUrl + "/api/Lookup/Geography?";
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGeographyPickerAreas(_response);
        });
    }

    protected processGeographyPickerAreas(response: Response): Promise<GeographicAreaSelectionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GeographicAreaSelectionViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GeographicAreaSelectionViewModel[]>(<any>null);
    }

    /**
     * Retrieve map key
     */
    mapKey(): Promise<string> {
        let url_ = this.baseUrl + "/api/Lookup/MapKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMapKey(_response);
        });
    }

    protected processMapKey(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Retrieve Map credentials
     */
    mapCredentials(): Promise<string> {
        let url_ = this.baseUrl + "/api/Lookup/MapCredentials";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMapCredentials(_response);
        });
    }

    protected processMapCredentials(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Retrieve CDN Root
     */
    cdnRoot(): Promise<string | null> {
        let url_ = this.baseUrl + "/api/Lookup/CdnRoot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCdnRoot(_response);
        });
    }

    protected processCdnRoot(response: Response): Promise<string | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }

    /**
     * Retrieve app insights key
     */
    insights(): Promise<string> {
        let url_ = this.baseUrl + "/api/Lookup/Insights";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsights(_response);
        });
    }

    protected processInsights(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Retrieve recaptcha public key
     */
    recaptcha(): Promise<string> {
        let url_ = this.baseUrl + "/api/Lookup/Recaptcha";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecaptcha(_response);
        });
    }

    protected processRecaptcha(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Validate whether input zipcode is valid
     * @param code (optional) 
     */
    validateZip(code: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Lookup/Zip?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateZip(_response);
        });
    }

    protected processValidateZip(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * Validate whether requested amount is available
     * @param amount (optional) 
     */
    loanAmount(amount: number | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Lookup/Amount?";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoanAmount(_response);
        });
    }

    protected processLoanAmount(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class StatisticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Retrieve snapshot of every lead in the selected date range with the
    latest status of the lead in the date range
     * @param start (optional) 
     * @param end (optional) 
     */
    leadsWithReferralInfo(start: Date | undefined, end: Date | undefined, partner: string): Promise<LeadWithReferralInfo[]> {
        let url_ = this.baseUrl + "/api/{partner}/Statistics/Leads/WithReferralInfo?";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeadsWithReferralInfo(_response);
        });
    }

    protected processLeadsWithReferralInfo(response: Response): Promise<LeadWithReferralInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadWithReferralInfo[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadWithReferralInfo[]>(<any>null);
    }

    /**
     * Retrieve snapshot of every lead in the selected date range with the
    latest status of the lead in the date range as GEOJSON
     * @param start (optional) 
     * @param end (optional) 
     */
    leadsWithLocationInfo(start: Date | undefined, end: Date | undefined, partner: string): Promise<GeoJsonFeatureCollection> {
        let url_ = this.baseUrl + "/api/{partner}/Statistics/Leads/WithLocationInfo?";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeadsWithLocationInfo(_response);
        });
    }

    protected processLeadsWithLocationInfo(response: Response): Promise<GeoJsonFeatureCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GeoJsonFeatureCollection>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GeoJsonFeatureCollection>(<any>null);
    }

    /**
     * Retrieve lead snapshots within the specified date range summarized
    by day and status
     * @param start (optional) 
     * @param end (optional) 
     * @param request (optional) 
     */
    leadsSummary(start: Date | undefined, end: Date | undefined, request: LeadsSummaryType | undefined, partner: string): Promise<LeadSummary> {
        let url_ = this.baseUrl + "/api/{partner}/Statistics/Leads/Summary?";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&"; 
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&"; 
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeadsSummary(_response);
        });
    }

    protected processLeadsSummary(response: Response): Promise<LeadSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadSummary>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadSummary>(<any>null);
    }

    /**
     * Retrieve product associated with input partner with its geographic state and area prefix
     */
    productsWithLocationInfo(partner: string): Promise<ProductAndLocation[]> {
        let url_ = this.baseUrl + "/api/{partner}/Statistics/Products/WithLocationInfo";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsWithLocationInfo(_response);
        });
    }

    protected processProductsWithLocationInfo(response: Response): Promise<ProductAndLocation[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProductAndLocation[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAndLocation[]>(<any>null);
    }

    /**
     * Retrieve referral partners with their geographic coverage area
     */
    referrersWithLocationInfo(partner: string): Promise<{ [key: string]: string[]; }> {
        let url_ = this.baseUrl + "/api/{partner}/Statistics/Referrers/WithLocationInfo";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReferrersWithLocationInfo(_response);
        });
    }

    protected processReferrersWithLocationInfo(response: Response): Promise<{ [key: string]: string[]; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <{ [key: string]: string[]; }>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string[]; }>(<any>null);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Retrieve users; filtered, sorted, and paged
     * @param filter (optional) 
     * @param sortBy (optional) 
     * @param includeCount (optional) 
     * @param sortDirection (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    find(filter: string | undefined, sortBy: string | null | undefined, includeCount: boolean | undefined, sortDirection: SortDirection | undefined, page: number | undefined, pageSize: number | undefined, partner: string): Promise<GridDataOfUserViewModel> {
        let url_ = this.baseUrl + "/api/{partner}/Users?";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (includeCount === null)
            throw new Error("The parameter 'includeCount' cannot be null.");
        else if (includeCount !== undefined)
            url_ += "IncludeCount=" + encodeURIComponent("" + includeCount) + "&"; 
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<GridDataOfUserViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GridDataOfUserViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GridDataOfUserViewModel>(<any>null);
    }

    /**
     * Updates a single user
     */
    edit(form: UserViewModel, partner: string): Promise<void> {
        let url_ = this.baseUrl + "/api/{partner}/Users";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEdit(_response);
        });
    }

    protected processEdit(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Send an invitation to a user
     */
    sendInvite(invite: InviteUserViewModel, partner: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/{partner}/Users/SendInvite";
        if (partner === undefined || partner === null)
            throw new Error("The parameter 'partner' must be defined.");
        url_ = url_.replace("{partner}", encodeURIComponent("" + partner)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invite);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendInvite(_response);
        });
    }

    protected processSendInvite(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ValidationProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export interface UserProfileViewModel {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    title: string;
    phone: string;
    image: ImageViewModel;
    aboutMe?: string | undefined;
    customQuote?: string | undefined;
}

export interface ImageViewModel {
    url?: string | undefined;
    imageData?: any | undefined;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export interface ValidationProblemDetails extends ProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export interface LoginViewModel {
    username: string;
    password: string;
    recaptchaToken: string;
}

export interface ForgotPasswordViewModel {
    email: string;
    recaptchaToken: string;
}

export interface PasswordResetViewModel {
    password: string;
    confirmPassword: string;
}

export interface ViewInviteViewModel extends UserProfileViewModel {
    password: string;
    confirmPassword: string;
    accountExists: boolean;
}

export interface PasswordChangeViewModel extends PasswordResetViewModel {
    currentPassword: string;
}

export interface GridDataOfLeadViewModel {
    items: LeadViewModel[];
    total?: number | undefined;
}

export interface LeadViewModel {
    id: string;
    status: LoanStatus;
    dateCreated: Date;
    statusDate: Date;
    firstName?: string | undefined;
    lastName?: string | undefined;
    nameOfBusiness?: string | undefined;
    amount: number;
    useOfProceeds?: string | undefined;
    leadSource?: string | undefined;
    referredTo?: string | undefined;
    referralCode?: string | undefined;
}

export enum LoanStatus {
    Referred = 0,
    Unmatched = 1,
    Matched = 2,
    Reviewed = 3,
    Contacted = 4,
    Qualified = 8,
    Funded = 10,
    Disqualified = 20,
    Abandoned = 30,
}

export enum SortDirection {
    Asc = 0,
    Desc = 1,
}

export interface GridDataOfLeadWithStatsViewModel {
    items: LeadWithStatsViewModel[];
    total?: number | undefined;
}

export interface LeadWithStatsViewModel extends LeadViewModel {
    requestedAmount: number;
    businessType: SingleBusinessType;
    industry?: string | undefined;
    yearsInBusiness: SingleYearsInBusiness;
    numEmployees?: number | undefined;
    priorBankruptcies: SinglePriorBankruptcies;
    revenueLastYear: GrossRevenue;
    revenueProjected: GrossRevenue;
    netProfit?: number | undefined;
    hasBusinessPlan?: boolean | undefined;
    collateralTypes: string[];
    statistics?: StatisticsViewModel | undefined;
    businessAddress?: AddressViewModel | undefined;
    matchedProduct_Name?: string | undefined;
    leadOwner?: string | undefined;
    ownershipDemographicTypes: string[];
}

export enum SingleBusinessType {
    SoleProprietorship = 1,
    LLC = 2,
    Corporation = 4,
    NonProfit = 8,
    Other = 16,
}

export enum SingleYearsInBusiness {
    Startup = 1,
    LessThanOne = 2,
    OneToTwo = 4,
    TwoToThree = 8,
    ThreeOrMore = 16,
}

export enum SinglePriorBankruptcies {
    None = 1,
    _1Prior = 2,
    _2OrMore = 4,
}

export enum GrossRevenue {
    LessThan100000 = 99999,
    _100000To250000 = 250000,
    _250000To500000 = 500000,
    _500000To1000000 = 1000000,
    _1000000To5000000 = 5000000,
    MoreThan5000000 = 5000001,
}

export interface StatisticsViewModel {
    censusTract?: string | undefined;
    isCDFIInvestmentArea?: boolean | undefined;
    craEligibleTract?: boolean | undefined;
    povertyRateAverage?: number | undefined;
    unemploymentRate?: number | undefined;
}

export interface AddressViewModel {
    line1: string;
    line2: string;
    city: string;
    state: string;
    zip: string;
}

export interface LeadDetailViewModel extends LeadWithStatsViewModel {
    phone?: string | undefined;
    email?: string | undefined;
    ficoScore: SingleCreditScores;
    financedNeededBy?: FinanceTimeline | undefined;
    businessOwner?: string | undefined;
    howDidYouHear?: HowDidYouHear | undefined;
    preferredContactTime?: PreferredContactTime | undefined;
    preferredContactMethod?: PreferredContactMethod | undefined;
    hasDiverseOwnership?: boolean | undefined;
    state: LoanState;
}

export enum SingleCreditScores {
    _700Plus = 1,
    _660To699 = 2,
    _640To659 = 4,
    _620To639 = 8,
    _580To619 = 16,
    Below580 = 32,
}

export enum FinanceTimeline {
    Today = 0,
    InNextTwoWeeks = 1,
    InNextTwoMonths = 2,
    MultipleOptions = 3,
}

export enum HowDidYouHear {
    Google = 0,
    Facebook = 1,
    Ad = 2,
    Email = 3,
    Event = 4,
    WordOMouth = 5,
    LenderReferral = 6,
    Other = 7,
}

export enum PreferredContactTime {
    Morning = 0,
    Afternoon = 1,
    Evening = 2,
}

export enum PreferredContactMethod {
    Email = 0,
    Phone = 1,
}

export enum LoanState {
    InProgress = 0,
    Submitted = 1,
    Removed = 2,
}

export interface GeographicAreaSelectionViewModel {
    areaName: string;
    state: string;
}

export interface LeadWithReferralInfo {
    status: LoanStatus;
    requestedAmount: number;
    referredBy?: string | undefined;
    referredTo?: string | undefined;
}

export interface GeoJsonFeatureCollection {
}

export interface LeadSummary {
    summary?: LeadSummaryByDate[] | undefined;
    pipelineAverage?: LeadPipelineAverage | undefined;
}

export interface LeadSummaryByDate {
    date: Date;
    pending: number;
    contacted: number;
    funded: number;
    disqualified: number;
}

export interface LeadPipelineAverage {
    averageDaysPending?: number | undefined;
    averageDaysContacted?: number | undefined;
    averageDaysFunded?: number | undefined;
}

export enum LeadsSummaryType {
    Summary = 1,
    Average = 2,
}

export interface ProductAndLocation {
    name: string;
    lender: string;
    prefix: string;
}

export interface GridDataOfUserViewModel {
    items: UserViewModel[];
    total?: number | undefined;
}

export interface UserViewModel {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    createdBy: string;
    dateCreated: Date;
    image: ImageViewModel;
    roles: UserRoleViewModel[];
    status: UserStatus;
    fullName: string;
    selectedRole?: RoleType | undefined;
    selectedRoleDisplay?: string | undefined;
    isActive: boolean;
}

export interface UserRoleViewModel {
    roleType: RoleType;
    partner: string;
}

export enum RoleType {
    PartnerUser = 0,
    PartnerAdministrator = 1,
    SystemAdministrator = 2,
}

export enum UserStatus {
    Inactive = 0,
    Active = 1,
}

export interface InviteUserViewModel {
    email: string;
    firstName: string;
    lastName: string;
    selectedRole: RoleType;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}